const e = (() => { let e = null; const t = new Map, n = new Map; let o = 0; const r = new WeakMap; function h(e, t = {}, ...n) { return { __type: e, props: t, children: n.flat(), key: t?.key ?? null } } function createElement(e, t = "", n = 0) { if ("string" == typeof e || "number" == typeof e) return document.createTextNode(String(e)); if (!e || "object" != typeof e || !e.__type) throw new Error("Invalid vnode: " + JSON.stringify(e)); if ("function" == typeof e.__type) throw new Error("createElement should not be called with functional components."); const o = document.createElement(e.__type); setProps(o, e.props || {}); const r = getComponentId(e, t, n); for (let t = 0; t < (e.children || []).length; t++) { const n = e.children[t]; o.appendChild(createElement(resolveVNode(n, o, t, r), r, t)) } return o } function resolveVNode(e, t, n, o = "") { for (; e && "function" == typeof e.__type;) { const r = getComponentId(e, o, n); e = renderComponent(e, t, n, o), o = r } return e } function setProps(e, t) { for (const n in t) n.startsWith("on") ? e[n.toLowerCase()] = t[n] : e.setAttribute(n, t[n]) } function updateProps(e, t, n) { const o = new Set([...Object.keys(t), ...Object.keys(n)]); for (const r of o) { const o = t[r]; o !== n[r] && (r.startsWith("on") ? e[r.toLowerCase()] = o || null : null == o ? e.removeAttribute(r) : e.setAttribute(r, o)) } } function getComponentId(e, t, n) { let o = "Unknown"; "function" == typeof e?.__type ? o = e.__type.name || "Anon" : "string" == typeof e?.__type && (o = e.__type); return `${t}/${o}:${e?.key ?? n}` } function renderComponent(n, o, r, s = "") { const a = getComponentId(n, s, r); let c = t.get(a); const u = e; c || (c = { hooks: [], hookIndex: 0, effects: [], vnode: n, parent: o, index: r, render: null, renderedVNode: null }, t.set(a, c), c.render = () => { c.hookIndex = 0, c.effects = [], e = c; const t = c.vnode.__type(c.vnode.props), n = getComponentId(c.vnode, s, c.index); patch(c.parent, t, c.renderedVNode, c.index, n), c.renderedVNode = t, e = null, c.effects.forEach((e => e())) }), e = c, c.hookIndex = 0, c.effects = [], c.vnode = n, c.parent = o, c.index = r; const d = n.__type(n.props); return c.renderedVNode = d, e = u, c.effects.forEach((e => e())), c.renderedVNode } function patch(e, n, o, r = 0, s = "") { const a = e.childNodes[r]; if (!n) return void (a && e.removeChild(a)); if ("function" == typeof n?.__type) { const a = renderComponent(n, e, r, s), c = t.get(getComponentId(o, s, r)), u = c?.renderedVNode; return void patch(e, a, u, r, s) } if (typeof n != typeof o || ("string" == typeof n || "number" == typeof n) && n !== o || n?.__type !== o?.__type) { const t = createElement(resolveVNode(n, e, r, s), s, r); return void (a ? e.replaceChild(t, a) : e.appendChild(t)) } if (!("string" != typeof n && "number" != typeof n || "string" != typeof o && "number" != typeof o)) { const e = String(n); return void (a.textContent !== e && (a.textContent = e)) } updateProps(a, n.props || {}, o.props || {}); const c = n.children || [], u = o.children || [], d = getComponentId(n, s, r); for (!function cleanupSubtree(e) { for (const [n, o] of t.entries()) n.startsWith(e) && (cleanupEffects(o), t.delete(n)) }(d); a.childNodes.length > c.length;)a.removeChild(a.lastChild); const p = Math.max(c.length, u.length); for (let e = 0; e < p; e++)patch(a, c[e], u[e], e, d) } function useState(t) { const n = e, o = n.hookIndex++; return n.hooks[o] || (n.hooks[o] = { value: t, set: e => { n.hooks[o].value = e, n.render && n.render() } }), [n.hooks[o].value, n.hooks[o].set] } function cleanupEffects(e) { if (e && Array.isArray(e.hooks)) for (const t of e.hooks) t && "function" == typeof t.cleanup && t.cleanup() } function useEffect(t, n) { const o = e, r = o.hookIndex++, s = o.hooks[r]; !s || !n || n.some(((e, t) => !Object.is(e, s.deps?.[t]))) ? (s && s.cleanup, o.hooks[r] = { deps: n }, o.effects.push((() => { const e = t(); "function" == typeof e && (o.hooks[r].cleanup = e) }))) : o.hooks[r] = s } function renderApp(t, n) { n.__SynactJSCtx || (n.__SynactJSCtx = { hooks: [], hookIndex: 0, effects: [], vnode: null, render: null, renderedVNode: null, parent: n, index: 0, render: null, hooks: [], effects: [] }); const s = n.__SynactJSCtx; s.render = () => { s.hookIndex = 0, s.effects = [], e = s; const a = t(); patch(n, a, s.vnode, 0, function generateContainerId(e) { return r.has(e) || r.set(e, "/Mount" + o++), r.get(e) }(n)), s.vnode = a, e = null, s.effects.forEach((e => e())) }, s.render() } function useRouter() { const [e, t] = useState(window.location.pathname); useEffect((() => { const onPop = () => t(window.location.pathname); window.addEventListener("popstate", onPop); const onClick = e => { const n = e.target.closest("a"); if (n && n.href && !e.defaultPrevented && 0 === e.button && !e.metaKey && !e.ctrlKey && !e.shiftKey && !e.altKey && n.origin === location.origin) { e.preventDefault(); const o = n.pathname; history.pushState({}, "", o), t(o) } }; return window.addEventListener("click", onClick), () => { window.removeEventListener("popstate", onPop), window.removeEventListener("click", onClick) } }), [e]); return [e, n => { n !== e && (history.pushState({}, "", n), t(n)) }] } function Fragment(e) { return e.children } const tag = e => (t, ...n) => h(e, t, ...n), s = tag("div"), a = tag("h1"), c = tag("h2"), u = tag("h3"), d = tag("h4"), p = tag("h5"), i = tag("p"), l = tag("button"), f = tag("strong"), m = tag("span"), y = tag("ul"), v = tag("li"), g = tag("input"), w = tag("form"), b = tag("label"), C = tag("a"), k = tag("nav"), x = tag("hr"), S = tag("i"), _ = tag("section"), E = tag("pre"), I = tag("code"), A = tag("img"), V = tag("table"), N = tag("thead"), P = tag("tbody"), J = tag("tr"), M = tag("td"), R = tag("th"), O = tag("footer"), L = tag("header"), j = tag("main"), F = tag("textarea"), $ = tag("select"), K = tag("option"), W = tag("svg"), D = tag("br"), q = tag("small"), T = tag("ol"), U = tag("dl"), z = tag("dt"), B = tag("dd"), G = tag("fieldset"); return { h: h, useState: useState, useEffect: useEffect, useContext: function useContext(e) { return n.has(e.id) ? n.get(e.id) : e.defaultValue }, useMemo: function useMemo(t, n) { const o = e, r = o.hookIndex++; let s = o.hooks[r]; if (!s || !n || n.some(((e, t) => !Object.is(e, s.deps?.[t])))) { const e = t(); return o.hooks[r] = { value: e, deps: n }, e } return s.value }, useCallback: function useCallback(t, n) { const o = e, r = o.hookIndex++; let s = o.hooks[r]; return s && n && !n.some(((e, t) => !Object.is(e, s.deps?.[t]))) ? "function" == typeof s.value ? s.value : t : (o.hooks[r] = { value: t, deps: n }, t) }, createContext: function createContext(e) { const t = Symbol("context"); return { id: t, defaultValue: e, Provider: ({ value: e, children: o }) => (n.set(t, e), Array.isArray(o) ? h(Fragment, {}, ...o) : o) } }, renderApp: renderApp, RouteView: function RouteView({ routes: e }) { const [t] = useRouter(), n = e[t] || e["*"]; return s({}, n ? n() : null) }, Fragment: Fragment, contextMap: t, mountComponents: function mountComponents() { document.querySelectorAll("[data-component]").forEach((e => { const t = e.getAttribute("data-component")?.trim(), n = window.SynactJS.components.find((e => e.name === t)) || window[t]; let o = {}; const r = e.getAttribute("data-prop"); if (r) try { o = JSON.parse(r) } catch (e) { console.warn(`[SynactJS] Invalid JSON in data-prop for component ${t}:`, e) } "function" == typeof n && renderApp((() => h(n, o)), e) })) }, useRouter: useRouter, div: s, h1: a, h2: c, h3: u, h4: d, h5: p, p: i, button: l, strong: f, span: m, ul: y, li: v, input: g, form: w, label: b, a: C, nav: k, hr: x, i: S, section: _, pre: E, code: I, img: A, table: V, thead: N, tbody: P, tr: J, td: M, th: R, footer: O, header: L, main: j, textarea: F, select: $, option: K, svg: W, br: D, small: q, ol: T, dl: U, dt: z, dd: B, fieldset: G, createElement: createElement, setProps: setProps, updateProps: updateProps, patch: patch } })(), { h: t, useState: n, useEffect: o, useContext: r, useMemo: s, useCallback: a, createContext: c, renderApp: u, RouteView: d, Fragment: p, useRouter: i, contextMap: l, mountComponents: f, div: m, h1: y, h2: v, h3: g, h4: w, h5: b, p: C, button: k, strong: x, span: S, ul: _, li: E, input: I, form: A, label: V, a: N, nav: P, createElement: J, setProps: M, updateProps: R, patch: O } = e, L = { components: [], register: function (e) { console.log(`[SynactJS] Registering component: ${e.name}`), this.components.push(e), f() } }; "undefined" != typeof window && (Object.assign(window, { h: t, useState: n, useEffect: o, useContext: r, useMemo: s, useCallback: a, createContext: c, renderApp: u, RouteView: d, Fragment: p, useRouter: i, div: m, h1: y, h2: v, h3: g, h4: w, h5: b, p: C, button: k, strong: x, span: S, ul: _, li: E, input: I, form: A, label: V, a: N, nav: P, createElement: J, setProps: M, updateProps: R, patch: O, SynactJS: L }), window.SynactJS = L, Object.assign(window, { SynactJS: L }), document.addEventListener("DOMContentLoaded", (() => { f() })), window.addEventListener("beforeunload", (() => { for (const e of l.values()) cleanupEffects(e); l.clear() }))), "undefined" != typeof module && module.exports && (module.exports = { h: t, useState: n, useEffect: o, useContext: r, useMemo: s, useCallback: a, createContext: c, renderApp: u, RouteView: d, Fragment: p, useRouter: i, div: m, h1: y, h2: v, h3: g, h4: w, h5: b, p: C, button: k, strong: x, span: S, ul: _, li: E, input: I, form: A, label: V, a: N, nav: P, createElement: J, setProps: M, updateProps: R, patch: O, SynactJS: L });