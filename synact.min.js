const e = (() => { let e = null; const t = new Map, n = new Map; let o = 0; const r = new WeakMap; function h(e, t = {}, ...n) { return { __type: e, props: t, children: n.flat(), key: t?.key ?? null } } function createElement(e, t = "", n = 0) { if ("string" == typeof e || "number" == typeof e) return document.createTextNode(String(e)); if (!e || "object" != typeof e || !e.__type) throw new Error("Invalid vnode: " + JSON.stringify(e)); if ("function" == typeof e.__type) throw new Error("createElement should not be called with functional components."); const o = document.createElement(e.__type); setProps(o, e.props || {}); const r = getComponentId(e, t, n); for (let t = 0; t < (e.children || []).length; t++) { const n = e.children[t]; o.appendChild(createElement(resolveVNode(n, o, t, r), r, t)) } return o } function resolveVNode(e, t, n, o = "") { for (; e && "function" == typeof e.__type;) { const r = getComponentId(e, o, n); e = renderComponent(e, t, n, o), o = r } return e } function setProps(e, t) { for (const n in t) n.startsWith("on") ? e[n.toLowerCase()] = t[n] : e.setAttribute(n, t[n]) } function updateProps(e, t, n) { const o = new Set([...Object.keys(t), ...Object.keys(n)]); for (const r of o) { const o = t[r]; o !== n[r] && (r.startsWith("on") ? e[r.toLowerCase()] = o || null : null == o ? e.removeAttribute(r) : e.setAttribute(r, o)) } } function getComponentId(e, t, n) { let o = "Unknown"; "function" == typeof e?.__type ? o = e.__type.name || "Anon" : "string" == typeof e?.__type && (o = e.__type); return `${t}/${o}:${e?.key ?? n}` } function renderComponent(n, o, r, s = "") { const c = getComponentId(n, s, r); let u = t.get(c); const a = e; u || (u = { hooks: [], hookIndex: 0, effects: [], vnode: n, parent: o, index: r, render: null, renderedVNode: null }, t.set(c, u), u.render = () => { u.hookIndex = 0, u.effects = [], e = u; const t = u.vnode.__type(u.vnode.props), n = getComponentId(u.vnode, s, u.index); patch(u.parent, t, u.renderedVNode, u.index, n), u.renderedVNode = t, e = null, u.effects.forEach((e => e())) }), e = u, u.hookIndex = 0, u.effects = [], u.vnode = n, u.parent = o, u.index = r; const p = n.__type(n.props); return u.renderedVNode = p, e = a, u.effects.forEach((e => e())), u.renderedVNode } function patch(e, n, o, r = 0, s = "") { const c = e.childNodes[r]; if (!n) return void (c && e.removeChild(c)); if ("function" == typeof n?.__type) { const c = renderComponent(n, e, r, s), u = t.get(getComponentId(o, s, r)), a = u?.renderedVNode; return void patch(e, c, a, r, s) } if (typeof n != typeof o || ("string" == typeof n || "number" == typeof n) && n !== o || n?.__type !== o?.__type) { const t = createElement(resolveVNode(n, e, r, s), s, r); return void (c ? e.replaceChild(t, c) : e.appendChild(t)) } if (!("string" != typeof n && "number" != typeof n || "string" != typeof o && "number" != typeof o)) { const e = String(n); return void (c.textContent !== e && (c.textContent = e)) } updateProps(c, n.props || {}, o.props || {}); const u = n.children || [], a = o.children || [], p = getComponentId(n, s, r); for (!function cleanupSubtree(e) { for (const [n, o] of t.entries()) n.startsWith(e) && (cleanupEffects(o), t.delete(n)) }(p); c.childNodes.length > u.length;)c.removeChild(c.lastChild); const d = Math.max(u.length, a.length); for (let e = 0; e < d; e++)patch(c, u[e], a[e], e, p) } function useState(t) { const n = e, o = n.hookIndex++; return n.hooks[o] || (n.hooks[o] = { value: t, set: e => { n.hooks[o].value = e, n.render && n.render() } }), [n.hooks[o].value, n.hooks[o].set] } function cleanupEffects(e) { if (e && Array.isArray(e.hooks)) for (const t of e.hooks) t && "function" == typeof t.cleanup && t.cleanup() } function useEffect(t, n) { const o = e, r = o.hookIndex++, s = o.hooks[r]; !s || !n || n.some(((e, t) => !Object.is(e, s.deps?.[t]))) ? (s && s.cleanup, o.hooks[r] = { deps: n }, o.effects.push((() => { const e = t(); "function" == typeof e && (o.hooks[r].cleanup = e) }))) : o.hooks[r] = s } function renderApp(t, n) { n.__SynactJSCtx || (n.__SynactJSCtx = { hooks: [], hookIndex: 0, effects: [], vnode: null, render: null, renderedVNode: null, parent: n, index: 0, render: null, hooks: [], effects: [] }); const s = n.__SynactJSCtx; s.render = () => { s.hookIndex = 0, s.effects = [], e = s; const c = t(); patch(n, c, s.vnode, 0, function generateContainerId(e) { return r.has(e) || r.set(e, "/Mount" + o++), r.get(e) }(n)), s.vnode = c, e = null, s.effects.forEach((e => e())) }, s.render() } function useRouter() { const [e, t] = useState(window.location.pathname); useEffect((() => { const onPop = () => t(window.location.pathname); window.addEventListener("popstate", onPop); const onClick = n => { const o = n.target.closest("a"); if (o && o.href && !n.defaultPrevented && 0 === n.button && !n.metaKey && !n.ctrlKey && !n.shiftKey && !n.altKey && o.origin === location.origin) { n.preventDefault(); const r = o.pathname; r !== e && (history.pushState({}, "", r), t(r)) } }; return window.addEventListener("click", onClick), () => { window.removeEventListener("popstate", onPop), window.removeEventListener("click", onClick) } }), [e]); return [e, n => { n !== e && (history.pushState({}, "", n), t(n)) }] } function Fragment(e) { return e.children } const tag = e => (t, ...n) => h(e, t, ...n), s = tag("div"), c = tag("h1"), u = tag("h2"), a = tag("h3"), p = tag("h4"), d = tag("h5"), i = tag("p"), l = tag("button"), f = tag("strong"), m = tag("span"), y = tag("ul"), v = tag("li"), g = tag("input"), w = tag("form"), C = tag("label"), k = tag("a"), S = tag("nav"); return { h: h, useState: useState, useEffect: useEffect, useContext: function useContext(e) { return n.has(e.id) ? n.get(e.id) : e.defaultValue }, useMemo: function useMemo(t, n) { const o = e, r = o.hookIndex++; let s = o.hooks[r]; if (!s || !n || n.some(((e, t) => !Object.is(e, s.deps?.[t])))) { const e = t(); return o.hooks[r] = { value: e, deps: n }, e } return s.value }, useCallback: function useCallback(t, n) { const o = e, r = o.hookIndex++; let s = o.hooks[r]; return s && n && !n.some(((e, t) => !Object.is(e, s.deps?.[t]))) ? "function" == typeof s.value ? s.value : t : (o.hooks[r] = { value: t, deps: n }, t) }, createContext: function createContext(e) { const t = Symbol("context"); return { id: t, defaultValue: e, Provider: ({ value: e, children: o }) => (n.set(t, e), Array.isArray(o) ? h(Fragment, {}, ...o) : o) } }, renderApp: renderApp, RouteView: function RouteView({ routes: e }) { const [t] = useRouter(), n = e[t] || e["*"]; return s({}, n ? n() : null) }, Fragment: Fragment, contextMap: t, mountComponents: function mountComponents() { document.querySelectorAll("[data-component]").forEach((e => { const t = e.getAttribute("data-component")?.trim(), n = window.SynactJS.components.find((e => e.name === t)) || window[t]; let o = {}; const r = e.getAttribute("data-prop"); if (r) try { o = JSON.parse(r) } catch (e) { console.warn(`[SynactJS] Invalid JSON in data-prop for component ${t}:`, e) } "function" == typeof n && renderApp((() => h(n, o)), e) })) }, useRouter: useRouter, div: s, h1: c, h2: u, h3: a, h4: p, h5: d, p: i, button: l, strong: f, span: m, ul: y, li: v, input: g, form: w, label: C, a: k, nav: S, createElement: createElement, setProps: setProps, updateProps: updateProps, patch: patch } })(), { h: t, useState: n, useEffect: o, useContext: r, useMemo: s, useCallback: c, createContext: u, renderApp: a, RouteView: p, Fragment: d, useRouter: i, contextMap: l, mountComponents: f, div: m, h1: y, h2: v, h3: g, h4: w, h5: C, p: k, button: S, strong: b, span: x, ul: _, li: E, input: I, form: A, label: V, a: N, nav: P, createElement: J, setProps: M, updateProps: R, patch: O } = e, L = { components: [], register: function (e) { console.log(`[SynactJS] Registering component: ${e.name}`), this.components.push(e), f() } }; "undefined" != typeof window && (Object.assign(window, { h: t, useState: n, useEffect: o, useContext: r, useMemo: s, useCallback: c, createContext: u, renderApp: a, RouteView: p, Fragment: d, useRouter: i, div: m, h1: y, h2: v, h3: g, h4: w, h5: C, p: k, button: S, strong: b, span: x, ul: _, li: E, input: I, form: A, label: V, a: N, nav: P, createElement: J, setProps: M, updateProps: R, patch: O, SynactJS: L }), window.SynactJS = L, Object.assign(window, { SynactJS: L }), document.addEventListener("DOMContentLoaded", (() => { f() })), window.addEventListener("beforeunload", (() => { for (const e of l.values()) cleanupEffects(e); l.clear() }))), "undefined" != typeof module && module.exports && (module.exports = { h: t, useState: n, useEffect: o, useContext: r, useMemo: s, useCallback: c, createContext: u, renderApp: a, RouteView: p, Fragment: d, useRouter: i, div: m, h1: y, h2: v, h3: g, h4: w, h5: C, p: k, button: S, strong: b, span: x, ul: _, li: E, input: I, form: A, label: V, a: N, nav: P, createElement: J, setProps: M, updateProps: R, patch: O, SynactJS: L });